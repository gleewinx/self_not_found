<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1"
    />
    <title>440: Identity Expired</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: "JetBrains Mono", monospace;
        color: #ccc;
      }

      canvas.background {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        image-rendering: pixelated;
      }

      /* windows-95-style error box */
      .error-box {
        position: absolute;
        background: #c0c0c0;
        border: 2px solid #000;
        box-shadow:
          inset -1px -1px #fff,
          inset 1px 1px #404040,
          inset -2px -2px #808080,
          inset 2px 2px #dfdfdf;
        font-family: "MS Sans Serif", monospace;
        color: #000;
        width: 320px;
      }

      .error-titlebar {
        background: linear-gradient(to right, #000080, #1084d0);
        color: #fff;
        font-weight: bold;
        padding: 2px 6px;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: move;
      }

      .error-titlebar button {
        background: #c0c0c0;
        border: 1px solid #404040;
        font-size: 10px;
        line-height: 10px;
        padding: 0 4px;
        color: #000;
        cursor: default;
      }

      .error-content {
        padding: 14px 16px;
        background: #c0c0c0;
        border-top: 2px solid #dfdfdf;
        border-left: 2px solid #dfdfdf;
        border-right: 2px solid #808080;
        border-bottom: 2px solid #808080;
        font-size: 11px;
      }

      .error-buttons {
        text-align: right;
        margin-top: 10px;
      }

      .error-buttons button {
        background: #c0c0c0;
        border: 2px outset #fff;
        padding: 2px 10px;
        margin-left: 4px;
        font-size: 11px;
        cursor: pointer;
      }

      .error-buttons button:active {
        border: 2px inset #fff;
      }
    </style>
  </head>
  <body>
    <video
      id="webcam"
      autoplay
      playsinline
      style="display:none;"
    ></video>
    <canvas class="background"></canvas>

    <script>
      (async function () {
        const video = document.getElementById("webcam");
        // try to grab the webcam feed
        try {
          const stream =
            await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: false,
            });
          video.srcObject = stream;
        } catch (err) {
          alert("Webcam access denied or unavailable");
          return;
        }

        const bgCanvas = document.querySelector(".background");
        const bgCtx = bgCanvas.getContext("2d");

        // keep the canvas full-screen
        function resizeBackground() {
          bgCanvas.width = window.innerWidth;
          bgCanvas.height = window.innerHeight;
        }
        window.addEventListener("resize", resizeBackground);
        resizeBackground();

        // this controls how pixelated the base image is (higher = smaller pixels)
        const pixelScale = 0.1;

        const pixelCanvas = document.createElement("canvas");
        const pctx = pixelCanvas.getContext("2d");
        const videoCanvas = document.createElement("canvas");
        const vctx = videoCanvas.getContext("2d");

        // mirror control, false if already mirrored
        const shouldMirror = true;

        let lastBgUpdate = 0;
        let bgDelay = 50 + Math.random() * 150;

        function animate(timestamp) {
          if (video.videoWidth > 0) {
            videoCanvas.width = video.videoWidth;
            videoCanvas.height = video.videoHeight;

            // draw the video mirrored 
            vctx.save();
            if (shouldMirror) {
              vctx.translate(videoCanvas.width, 0);
              vctx.scale(-1, 1);
            }
            vctx.drawImage(
              video,
              0,
              0,
              videoCanvas.width,
              videoCanvas.height
            );
            vctx.restore();

            // bg update delay
            if (timestamp - lastBgUpdate > bgDelay) {
              lastBgUpdate = timestamp;
              bgDelay = 50 + Math.random() * 300;

              pixelCanvas.width = Math.max(
                1,
                video.videoWidth * pixelScale
              );
              pixelCanvas.height = Math.max(
                1,
                video.videoHeight * pixelScale
              );
              pctx.drawImage(
                videoCanvas,
                0,
                0,
                pixelCanvas.width,
                pixelCanvas.height
              );

              // pixel data grab, scramble
              const blockW = 4;
              const blockH = 4;
              const imgData = pctx.getImageData(
                0,
                0,
                pixelCanvas.width,
                pixelCanvas.height
              );
              const src = imgData.data;
              const copy = new Uint8ClampedArray(src);

              // this part randomly shifts small chunks of pixels
              // gives that compressed / bitsmosh kind of feel hihihihihi
              for (
                let y = 0;
                y < pixelCanvas.height;
                y += blockH
              ) {
                for (
                  let x = 0;
                  x < pixelCanvas.width;
                  x += blockW
                ) {
                  if (Math.random() < 0.15) {
                    const shiftX = Math.floor(
                      (Math.random() - 0.5) * 10
                    );
                    const shiftY = Math.floor(
                      (Math.random() - 0.5) * 6
                    );
                    for (let yy = 0; yy < blockH; yy++) {
                      for (let xx = 0; xx < blockW; xx++) {
                        const sx = Math.min(
                          pixelCanvas.width - 1,
                          Math.max(0, x + xx + shiftX)
                        );
                        const sy = Math.min(
                          pixelCanvas.height - 1,
                          Math.max(0, y + yy + shiftY)
                        );
                        const dx = x + xx;
                        const dy = y + yy;
                        const sIdx =
                          (sy * pixelCanvas.width + sx) * 4;
                        const dIdx =
                          (dy * pixelCanvas.width + dx) * 4;
                        src[dIdx] = copy[sIdx];
                        src[dIdx + 1] = copy[sIdx + 1];
                        src[dIdx + 2] = copy[sIdx + 2];
                        src[dIdx + 3] = 255;
                      }
                    }
                  }
                }
              }

              // drop the messed-up image back in
              pctx.putImageData(imgData, 0, 0);

              // scale it up so the pixels stay crispyyyy
              bgCtx.imageSmoothingEnabled = false;
              bgCtx.drawImage(
                pixelCanvas,
                0,
                0,
                bgCanvas.width,
                bgCanvas.height
              );

              // horizontal tearing — some scanlines get offset a bit 
              for (let y = 0; y < bgCanvas.height; y += 3) {
                if (Math.random() < 0.07) {
                  const tearX = (Math.random() - 0.5) * 80;
                  const tearH = 2 + Math.random() * 4;
                  bgCtx.drawImage(
                    bgCanvas,
                    0,
                    y,
                    bgCanvas.width,
                    tearH,
                    tearX,
                    y,
                    bgCanvas.width,
                    tearH
                  );
                }
              }

              // bigger chunks drift
              const blockSize = 32;
              for (
                let y = 0;
                y < bgCanvas.height;
                y += blockSize * 2
              ) {
                for (
                  let x = 0;
                  x < bgCanvas.width;
                  x += blockSize * 2
                ) {
                  if (Math.random() < 0.08) {
                    const shiftX =
                      (Math.random() - 0.5) * 30;
                    const shiftY =
                      (Math.random() - 0.5) * 20;
                    bgCtx.drawImage(
                      bgCanvas,
                      x,
                      y,
                      blockSize * 2,
                      blockSize * 2,
                      x + shiftX,
                      y + shiftY,
                      blockSize * 2,
                      blockSize * 2
                    );
                  }
                }
              }
            }
          }
          requestAnimationFrame(animate);
        }

        video.addEventListener("play", () =>
          requestAnimationFrame(animate)
        );

        // W3Schools comes to the rescue for the drag 
        function dragElement(elmnt) {
          let pos1 = 0,
            pos2 = 0,
            pos3 = 0,
            pos4 = 0;
          const header = document.getElementById(
            elmnt.id + "header"
          );
          if (header) {
            header.onmousedown = dragMouseDown;
          } else {
            elmnt.onmousedown = dragMouseDown;
          }

          function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
          }

          function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            elmnt.style.top =
              elmnt.offsetTop - pos2 + "px";
            elmnt.style.left =
              elmnt.offsetLeft - pos1 + "px";
          }

          function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
          }
        }

        let errorCounter = 0;

        // spawns the little fake error window that keeps coming back
        function spawnError() {
          const error =
            document.createElement("div");
          error.className = "error-box";

          const id = "errorBox" + ++errorCounter;
          error.id = id;

          error.style.left = `${
            Math.random() *
            (window.innerWidth - 340)
          }px`;
          error.style.top = `${
            Math.random() *
            (window.innerHeight - 180)
          }px`;

          error.innerHTML = `
      <div class="error-titlebar" id="${id}header">
        <span>Error 440 - Identity Expired</span>
        <button class="close-btn">×</button>
      </div>
      <div class="error-content">
        <p>Your current sense of self has timed out.<br>
        Please log in again — or take a deep breath and remember who you are.</p>
        <div class="error-buttons">
          <button class="retry-btn">Retry</button>
          <button class="cancel-btn">Cancel</button>
        </div>
      </div>`;

          document.body.appendChild(error);

          // make this specific window draggable via its titlebar
          dragElement(error);

          // when you close it, another one just pops up after a short pause
          const removeAndRespawn = () => {
            error.remove();
            setTimeout(
              spawnError,
              200 + Math.random() * 400
            );
          };

          error.querySelector(".close-btn").onclick =
            removeAndRespawn;
          error.querySelector(".retry-btn").onclick =
            removeAndRespawn;
          error.querySelector(".cancel-btn").onclick =
            removeAndRespawn;
        }

        spawnError();
      })();
    </script>
  </body>
</html>